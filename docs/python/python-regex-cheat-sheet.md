# Python Regex 备忘单

> 原文:[https://www.geeksforgeeks.org/python-regex-cheat-sheet/](https://www.geeksforgeeks.org/python-regex-cheat-sheet/)

正则表达式是 Python 编程或任何其他编程语言的重要组成部分。它用于搜索甚至替换指定的文本模式。在正则表达式中，一组字符共同构成了搜索模式。它也被称为 reg-ex 模式。Regex 的难点不是学习或理解它，而是记住语法以及如何根据我们的要求形成模式。所以这里我们提供了一个包含所有不同字符类、特殊字符、修饰符、集合等的 regex 备忘单。用于正则表达式中。

### 基本字符:

<figure class="table">

| 表示 | 

说明

 |
| --- | --- |
| 

#### t1】^T3】

 | 将表达式匹配到它的右边，在字符串经历换行符之前匹配到字符串的开头 |
| 

#### $

 | 将表达式匹配到它的左边，在字符串的末尾，在它经历换行符之前 |
| 

#### .

 | 匹配除换行符以外的任何字符 |
| 

#### 一

 | 恰好匹配一个字符 a |
| 

#### Normal male karyotype

 | 匹配字符串 xy |
| 

#### a&#124;b

 | 匹配表达式 a 或 b。如果 a 先匹配，b 不匹配。 |

</figure>

**示例:**

## 蟒蛇 3

```
import re

print(re.search(r"^x","xenon"))
print(re.search(r"s{content}quot;,"geeks"))
```

**输出:**

```
<re.Match object; span=(0, 1), match='x'>
<re.Match object; span=(4, 5), match='s'>
```

**说明:**

首先使用命令**导入 re** 导入 regex 模块

然后，在第一个示例中，我们使用 regex 在单词**“氙”**中搜索“**^x”**。 **^** 这个字符匹配它右边的表达式，在一个字符串的开头。因此， **^x** 将在字符串的开头搜索字符 x。由于**氙**以 **x 开始，**将找到匹配，并将返回匹配(' x ')及其位置(0，1)

类似地，在第二个例子中 **s$** 将搜索字符串末尾的字符 **s** ，现在由于极客以 **s** 结尾，因此它将找到匹配并将返回匹配(' s ')及其位置(4，5)。

### 量词:

<figure class="table">

| 公式 | 说明 |
| --- | --- |
| 

#### +

 | 将表达式向左匹配 1 次或更多次。 |
| 

#### *

 | 将表达式向左匹配 0 次或更多次。 |
| 

#### ？

 | 将表达式向左匹配 0 或 1 次 |
| 

#### {p}

 | 将表达式与其左边的 p 次匹配，不能少。 |
| 

#### {p，q}

 | 将表达式匹配到其左边的 p 到 q 倍，不能少。 |
| 

#### {p，}

 | 将表达式与其左侧 p 次或更多次匹配。 |
| 

#### {，q}

 | 将表达式向左匹配多达 q 次 |

</figure>

他们默认的搜索方法是贪婪。但是如果呢？被添加到限定符(+、*、和？它将以非贪婪的方式执行匹配。

**示例:**

## 蟒蛇 3

```
import re

print(re.search(r"9+","289908"))
print(re.search(r"\d{3}","hello1234"))
```

**输出:**

```
<re.Match object; span=(2, 4), match='99'>
<re.Match object; span=(5, 8), match='123'>
```

**说明:**

在第一个例子中， **9+** 将搜索数字 **9** 一次或多次。由于 **289908** 包含 **9** 两次，正则表达式将匹配它并打印匹配(' 99 ')及其位置(2，4)

在第二个示例中， **\d{3}** 将精确搜索数字 3 次。由于 **hello1234** 有数字，它将与首先遇到的 3 个数字 123 匹配，而不是 4，因为 **{3}** 将与 3 个数字匹配。因此它将打印匹配(' 123 ')及其位置(5，8)

### 字符类:

<figure class="table">

| 公式 | 说明 |
| --- | --- |
| 

#### \w

 | 匹配字母数字字符，即 a-z、A-Z、0-9 和下划线(_) |
| 

#### \W

 | 匹配非字母数字字符，即除 a-z、A-Z、0-9 和 _ |
| 

#### \d

 | 匹配数字，从 0 到 9。 |
| 

#### \D

 | 匹配任何非数字。 |
| 

#### \s

 | 匹配空白字符，也包括\t，\n，\r 和空格字符。 |
| 

#### \S

 | 匹配非空白字符。 |
| 

#### \A

 | 无论是单行模式还是多行模式，都将表达式匹配到字符串绝对开头的右侧。 |
| 

#### \Z

 | 无论是单行模式还是多行模式，都将表达式匹配到字符串绝对末尾的左侧。 |
| 

#### \n

 | 匹配换行符 |
| 

#### \t

 | 匹配制表符 |
| 

#### \b

 | 匹配单词开头和结尾的单词边界(或空字符串)。 |
| 

#### \B

 | 匹配\b 不匹配的地方，即非单词边界 |

</figure>

**示例:**

## 蟒蛇 3

```
import re

print(re.search(r"\s","xenon is a gas"))
print(re.search(r"\D+\d*","123geeks123"))
```

**输出:**

```
<re.Match object; span=(5, 6), match=' '>
<re.Match object; span=(3, 11), match='geeks123'>
```

**说明:**

在第一个例子中， **\s** 将搜索空格，并且每当它遇到第一个空格时，它将打印出该匹配。由于**氙是一种包含空格的气体**，它会遇到第一个空格并打印出匹配(')及其位置(5，6)

在第二个示例中， **\D+\d*** 将搜索一个或多个非数字字符，后跟 0 个或多个数字。在我们的案例中，**极客 123** 最符合描述，因为它包含 1 个或多个非数字字符(极客)，后跟 0 个或多个数字字符(123)。所以它会打印匹配(“极客 123”)及其位置(3，11)。

### 设置:

<figure class="table">

| 公式 | 说明 |
| --- | --- |
| 

#### 【ABC】

 | 匹配 a、b 或 c。它不匹配 abc。 |
| 

#### 【a-z】

 | 匹配从 a 到 z 的任何字母表。 |
| 

#### [A-Z]

 | 匹配从 A 到 Z 的任何大写字母 |
| 

#### 【a \-p】

 | 匹配，-或 p。它匹配–因为\转义了它。 |
| 

#### [-z]

 | 匹配–或 z |
| 

#### 【a-z0-9】

 | 匹配从 a 到 z 或从 0 到 9 的字符。 |
| 

#### [(+*)]

 | 特殊字符在集合中变成文字，因此这与(、+、*、或)匹配 |
| 

#### 【^ab5】

 | 添加^会排除集合中的任何字符。这里，它匹配不是 a、b 或 5 的字符。 |
| 

#### \[a\]

 | 匹配[a]，因为两个括号[ ]都被转义 |

</figure>

**示例:**

## 蟒蛇 3

```
import re

print(re.search(r"[^abc]","abcde"))
print(re.search(r"[a-p]","xenon"))
```

**输出:**

```
<re.Match object; span=(3, 4), match='d'>
<re.Match object; span=(1, 2), match='e'>
```

**说明:**

在第一个例子中，**【^abc】**将搜索除了 a、b 和 c 之外的任何东西，因此 regex 将匹配第一个不是 a、b 或 c 的字符，并将打印出该匹配。由于 **abcde** 包含 **d** 作为其第一个既不是 a 也不是 b 也不是 c 的匹配，因此它将打印出该匹配。所以匹配将是(' d ')，它的位置将是(3，4)

在第二个例子中，**【a-p】**将搜索 a 到 p 之间的字符。在**氙**中，a-p 之间的第一个单词是 **e** 它将打印出该搜索。所以匹配将是(' e ')，它的位置将是(1，2)

### 群组:

<figure class="table">

| 公式 | 说明 |
| --- | --- |
| 

#### ( )

 | 匹配括号内的表达式，并将其分组，我们可以根据需要捕获 |
| 

#### (？#……)

 | 阅读评论 |
| 

#### (? Private automatic branch exchange)

 | 匹配表达式 AB，该表达式可以用组名检索。 |
| 

#### (？:一)

 | 匹配由 A 表示的表达式，但之后无法检索。 |
| 

#### (？p =组)

 | 匹配由名为“group”的早期组匹配的表达式 |

</figure>

**示例:**

## 蟒蛇 3

```
import re

example = (re.search(r"(?:AB)","ACABC"))
print(example)
print(example.groups())

result = re.search(r"(\w*), (\w*)","geeks, best")
print(result.groups())
```

**输出:**

```
<re.Match object; span=(2, 4), match='AB'>
()
('geeks', 'best')
```

**说明:**

在第一个例子中，**(？:AB)** 将搜索匹配表达式 **AB** 并将打印出匹配及其位置。由于 **ACABC** 包含 **AB、**它将打印匹配(' AB ')及其位置(2，4)，但如前所述，之后无法检索。所以，如果我们尝试打印输出的组，它将显示一个空括号。

在第二个示例中，我们捕获了两组，一组包含 0 个或更多字母数字字符，后跟逗号和空格，另一组包含 0 个或更多字母数字字符。在**极客中，最佳极客**和**最佳**被捕获为第一和第二组。因此，当我们打印出这些组时，我们将会有(“极客”、“最佳”)作为捕获的组。

### 断言:

<figure class="table">

| 表示 | 说明 |
| --- | --- |
| 

#### 一(？=B)

 | 只有在表达式后面跟有 b 时，它才与表达式 A 匹配(正向预测断言) |
| 

#### 一(？！b)

 | 只有在表达式 A 后面没有跟表达式 b 的情况下，它才与表达式 A 匹配(否定前瞻断言) |
| 

#### (？<=乙)甲

 | 只有当 B 紧挨着它的左边时，它才与表达式 A 匹配。(断言背后的积极审视) |
| 

#### (？

 | 只有当 B 不在表达式的左侧时，它才与表达式 A 匹配。(断言后的否定表情) |
| 

#### (？()&#124;)

 | 如果有条件 |

</figure>

**示例:**

## 蟒蛇 3

```
import re

print(re.search(r"z(?=a)", "pizza"))
print(re.search(r"z(?!a)", "pizza"))
```

**输出:**

```
<re.Match object; span=(3, 4), match='z'>
<re.Match object; span=(2, 3), match='z'>
```

**说明:**

在第一个例子中， **z(？=a)** 会搜索后面跟字符 a 的字符 z，因为在**披萨，**我们有一个字符 **z** ，后面紧跟着字符**a**(piz**<u>za</u>**)，所以会有匹配。Regex 将打印匹配项(' z ')，后面跟着位置为(3，4)的 **a**

在第二个例子中， **z(？！a)** 将搜索字符 **z** ，该字符是**而不是**后跟字符 **a.** 因为在**披萨，**中我们有一个字符 **z** ，该字符后面不是 **a** 而是跟在**z**(pi**<u>ZZ</u>**a)，所以会有匹配。Regex 将打印匹配(' z ')，后面不跟有位置(2，3)的 **a**

### 标志:

<figure class="table">

| 表示 | 说明 |
| --- | --- |
| 

#### 一

 | 仅匹配 ASCII |
| 

#### I

 | 忽略大小写 |
| 

#### L

 | 区域设置字符类 |
| 

#### 米

 | ^和$匹配线的起点和终点(多线) |
| 

#### s

 | 匹配所有内容，包括换行符 |
| 

#### u

 | 匹配 Unicode 字符类 |
| 

#### x

 | 允许空格和注释(详细) |

</figure>

**示例:**

## 蟒蛇 3

```
import re

exp = """hello there
I am from
Geeks for Geeks"""

print(re.search(r"and", "Sun And Moon", flags=re.IGNORECASE)) 
print(re.findall(r"^\w", exp, flags = re.MULTILINE))
```

**输出:**

```
<re.Match object; span=(4, 7), match='And'>
['h', 'I', 'G']
```

**说明:**

在第一个例子中，IGNORECASE 标志将搜索单词**和**而不管其大小写(大写还是小写)，因此它忽略大小写并匹配表达式中的**和**。因此，它将打印匹配(' And ')及其位置(4，7)

在第二个例子中，MULTILINE 标志将搜索每一行，并在该行以字母数字字符开始时匹配。因为在多行**你好我是来自极客的极客，**每一行都以字母数字字符开始，所以它将匹配每一行，并将匹配打印在一个数组中(['h '，' I '，' G'])。

注意:在 MULTILINE 标志中，我们必须使用 re.findall，因为它有许多匹配项(对于每一行)