# 为什么我们需要 Python 中的不变量？

> 原文:[https://www . geeksforgeeks . org/为什么我们需要不变的 python/](https://www.geeksforgeeks.org/why-do-we-need-immutables-in-python/)

当一个新手进入编程世界，开始学习不同的概念，但最终到达**数据结构和算法**，学习和实现它们，但无论如何，他/她倾向于读一遍，忘记**不可变对象**。

**可变的和不变的**存在于每一种编程语言中，然而人们往往只关心可变的，比如列表、队列等，而不注意或很少注意不变的，因为在第一印象中它似乎只是一个附加组件，似乎没有任何现实生活中解决问题的应用程序，为了揭穿这个想法，让我们讨论一下这个概念、它的需求和局限性。

## 什么是不可变对象？

可变性是 Python 中数据类型的一个与众不同的属性，它与其他数据类型形成了很大的对比，它往往是数据类型在创建后允许被修改的一种能力，可以向其中添加值，也可以从中弹出值。另一方面，从另一个角度来看，也有一些对象不遵循这个原则，并且是不可更改的，在定义之后不允许对其进行任何修改。它的状态无论如何都不能改变，一旦初始化，它倾向于表示一个常数值。示例–整数、复数、字符串、浮点、元组、复数、冻结集。

因此，如果任何变量初始化了一个对应于这些不可变数据类型的值，就永远不能改变它。要改变它，你必须将同一个变量初始化为你想要的修改。当一个变量被重新分配给其他字符串时，它倾向于为两个对象分配不同的内存位置。

**例:**

## 蟒 3

```
# string initialized
var = 'Geeks'
print(id(var))
print(var)

# Reassigned to another value
var = 'For Geeks'

# New Memory Location assigned
print(id(var))
print(var)
```

**输出:**

```
139758810541392
Geeks
139758782345520
For Geeks
```

**注意:**在 Python 中，元组的不变性往往会有一个例外，因为元组本身是不可变的，但在初始化后不能修改，初始化时给它的值是它持有的最终值，没有什么可以向它添加或从中删除值，但是，像元组中嵌入的 List 这样的可变字段可以毫无错误地修改，但它证明了元组引用的对象可以修改，这种现象偶尔被称为**“不可传递的不变性”**。

在 Python 中，主要针对字符串对象，程序员在围绕不变性进行优化方面更有优势。

**例:**

## 蟒 3

```
var1 = 'GFG' 
var2 = 'GFG'
var3 = 'GFG'
var4 = 'GFG'
var5 = 'GFG'

# All the variables points to a
# single String
print(id(var1), id(var2), id(var3),
      id(var4), id(var5))
```

**输出:**

> 140080377558384 140080377558384 140080377558384 140080377558384 140080377558384

如果一个人倾向于一个接一个地创建 20 个字符串对象，保持相同的值，那么 Python 不会为每个值分配不同的内存位置，但它会使每个标识符引用相同的字符串，因为它永远不会被进一步修改，从而节省大量内存。例外的是，相同的场景并不适用于除了字符串之外的每个不可变对象，然而这个优化技巧被证明是依赖于实现的。

## 为什么要关心永恒？

1.  **提高了整个代码的准确性和简单性**，因为它为编码人员在程序中传递对象提供了便利，而没有任何恐惧，因为它似乎从未被修改过。而可变性更难推理。在易变性中，混叠导致许多不规则性，并最终威胁代码的保真度，最终导致可变性。
2.  **线程安全**–由于赋值后的对象不可修改，这就推断出一个只读数据正在线程间共享，这当然提供了线程安全。简单地说，在不变的情况下，因为对象没有变化的范围，所以不需要害怕从许多线程访问它。不可变对象的任何意义上的突变都可以通过这样一种方式来实现，即创建一个新的对象，而不是试图修改现有的对象。

## 限制

随着时间的推移，不同的结论随之而来，因为我们知道不变量是线程安全的，无论哪个线程读取它们的值，它们都会得到正确的值，但是不变量被发现对**“内存一致性错误”**免疫，这可以进一步解释为；不可变对象本身不是线程安全的。使用它们的代码必须是线程安全的。仅仅使用不可变对象还不足以实现这一点。人们还必须防止死锁、活锁和饥饿。