# Python 中的共享引用

> 原文:[https://www.geeksforgeeks.org/shared-reference-in-python/](https://www.geeksforgeeks.org/shared-reference-in-python/)

让我们给值 5 分配一个变量 x，给变量 x 分配另一个变量 y。

```py
x = 5
y = x
```

当 Python 查看第一条语句时，它首先创建一个对象来表示值 5。然后，它创建变量 x(如果它不存在的话)，并使它成为这个新对象 5 的引用。第二行导致 Python 创建变量 y，它没有被赋予 x，而是被用来引用 x 引用的那个对象。最终结果是变量 x 和 y 最终引用了同一个对象。这种多个名称引用同一个对象的情况，在 Python 中被称为**共享引用**。
现在，如果我们写道:

```py
x = 'Geeks'
```

这个语句创建了一个新对象来表示“极客”，并让 x 引用这个新对象。但是，y 仍然引用原始对象，即 5。如果我们再写一个陈述:

```py
b = 10
```

该语句导致创建一个新对象，并使 y 引用这个新对象。如果先前对象不再被引用，则该对象所拥有的空间将被回收，也就是说，该对象的空间将被自动扔回到可用空间池中，以供将来的对象重用。
这个物体空间的自动回收被称为垃圾回收。

## 共享参考和就地更改

存在执行就地对象更改的对象和操作。例如，对列表中某个元素的赋值实际上会就地更改列表对象本身，而不是创建一个新的列表对象。对于支持就地更改的对象，您需要非常小心共享引用，因为其中一个对象的更改会影响其他对象。

```py
L1 = [1, 2, 3, 4, 5]

L2 = L1
```

就像 x 和 y 一样，在语句 2 之后，L1 和 L2 将引用同一个对象。如果我们改变 L1 的第 0 名，现在想想会发生什么，是只改变 L1，还是同时改变 L1 和 L2？

```py
L1 = [1, 2, 3, 4, 5]
L2 = L1

L1[0] = 0

print(L1)
print(L2)
```

**输出:**

```py
[0, 2, 3, 4, 5]
[0, 2, 3, 4, 5]
```

因此，L1 的变化可以追溯到 L2。它不是为 L1 创建一个新对象，而是覆盖列表对象在该位置的部分。这是一个就地的改变。如果我们仍然希望为 L2 保留一个单独的副本，这样 L1 的任何变化都不会反映在 L2，那么我们可以请求 Python 为 L2 创建一个 L1 列表的副本。

```py
L1 = [1, 2, 3, 4, 5]
L2 = L1[:]

L1[0] = 0

print(L1)
print(L2)
```

**输出:**

```py
[0, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

**注意:**这种切片技术对字典和集合不起作用。

由于 Python 的引用模型，在 Python 程序中有两种不同的检查相等性的方法。

```py
L1 = [1, 2, 3, 4, 5]
L2 = L1

print(L1 == L2)
print(L1 is L2)
```

**输出:**

```py
True
True
```

第一种方法，`==`运算符测试被引用对象是否具有相同的值，如果具有相同的值，则返回真，否则返回假。第二种方法`is operator`测试对象的同一性——只有当两个名称都指向完全相同的对象时，它才返回真，所以基本上它是一种更强的相等测试形式。如果需要，它可以作为一种检测代码中共享引用的方法。如果名称指向相同但不同的对象，则返回 False。

**现在，来了一个棘手的部分:**
看下面的代码，

```py
L1 = [1, 2, 3, 4, 5]
L2 = [1, 2, 3, 4, 5]

print(L1 == L2)
print(L1 is L2)
```

**输出:**

```py
True
False
```

如果我们对小数字执行相同的操作，会发生什么:

```py
a = 50
b = 50

print(a == b)
print(a is b)
```

**输出:**

```py
True
True
```

因为小整数和字符串被缓存和重用，所以它们引用同一个对象。因为不能就地改变整数或字符串，所以对同一个对象有多少引用并不重要。